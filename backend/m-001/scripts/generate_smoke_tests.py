#!/usr/bin/env python3
import os
import sys
import fnmatch
from pathlib import Path
from typing import List, Tuple, Dict, Optional

from app import create_app

# This script inspects the Flask app's URL map to auto-generate a smoke-test suite
# targeting the deployed service via HTTP using requests.

OUTPUT_PATH = Path('tests/smoke/test_smoke_generated.py')
DEFAULT_BASE_URL = 'http://localhost:5000'


def _value_for_converter(conv) -> str:
    # Determine a representative sample value for a given converter instance
    name = conv.__class__.__name__.lower() if conv else ''
    try:
        # Werkzeug converters
        if 'integer' in name:
            return '1'
        if 'float' in name:
            return '1.0'
        if 'uuid' in name:
            return '123e4567-e89b-12d3-a456-426614174000'
        if 'path' in name:
            return 'test/path'
        if 'any' in name:
            # 'AnyConverter' may have choices
            choices = getattr(conv, 'choices', None)
            if choices:
                try:
                    # choices may be a set
                    return list(choices)[0]
                except Exception:
                    pass
            return 'test'
        # Default for string-like
        return 'test'
    except Exception:
        return 'test'


def _should_exclude(path: str, endpoint: str, exclude_patterns: List[str]) -> bool:
    if endpoint.startswith('static') or path.startswith('/static'):
        return True
    if endpoint.startswith('debugger'):
        return True
    for pat in exclude_patterns:
        if fnmatch.fnmatch(path, pat):
            return True
    return False


def collect_routes() -> Tuple[List[Tuple[str, str]], Optional[str], Optional[str]]:
    """
    Returns a tuple of:
      - list of (method, path) for GET/HEAD endpoints with sample param values
      - discovered health path if any
      - discovered version path if any
    """
    app = create_app()
    adapter = app.url_map.bind('localhost')

    exclude_patterns = [p.strip() for p in os.getenv('SMOKE_EXCLUDE_PATTERNS', '').split(',') if p.strip()]

    candidates: List[Tuple[str, str]] = []
    seen: set = set()
    health_path: Optional[str] = None
    version_path: Optional[str] = None

    for rule in app.url_map.iter_rules():
        methods = (rule.methods or set()).copy()
        # Only consider idempotent probes for smoke
        preferred_method = None
        if 'GET' in methods:
            preferred_method = 'GET'
        elif 'HEAD' in methods:
            preferred_method = 'HEAD'
        else:
            continue

        # Build path by filling in args
        kwargs = {}
        for arg in rule.arguments:
            conv = None
            try:
                conv = rule._converters.get(arg)  # type: ignore[attr-defined]
            except Exception:
                conv = None
            kwargs[arg] = _value_for_converter(conv)
        try:
            path = adapter.build(rule.endpoint, values=kwargs, force_external=False)
        except Exception:
            # Fallback: raw rule
            path = rule.rule
            for arg, val in kwargs.items():
                # naive replace
                path = path.replace(f'<{arg}>', str(val))

        if not path.startswith('/'):
            path = '/' + path

        if _should_exclude(path, rule.endpoint, exclude_patterns):
            continue

        key = (preferred_method, path)
        if key in seen:
            continue
        seen.add(key)
        candidates.append(key)

        # Track known utility endpoints
        if rule.endpoint.endswith('healthz') or path == '/healthz':
            health_path = path
        if rule.endpoint.endswith('version') or path == '/version':
            version_path = path

    # Stable ordering
    candidates.sort(key=lambda x: (x[1], x[0]))
    return candidates, health_path, version_path


def generate_test_file(routes: List[Tuple[str, str]], health_path: Optional[str], version_path: Optional[str]) -> str:
    base_url_env = os.getenv('SMOKE_BASE_URL') or os.getenv('BASE_URL') or DEFAULT_BASE_URL

    # Prepare list literal for test cases
    case_lines = []
    for method, path in routes:
        case_lines.append(f"    ('{method}', '{path}'),")
    cases_literal = '\n'.join(case_lines)

    health_literal = f"'{health_path}'" if health_path else 'None'
    version_literal = f"'{version_path}'" if version_path else 'None'

    content = f"""# Auto-generated by scripts/generate_smoke_tests.py
# Do not edit manually; changes will be overwritten on next generation.

import os
import time
import typing as _t

import pytest
import requests

BASE_URL = os.getenv('SMOKE_BASE_URL') or os.getenv('BASE_URL') or '{base_url_env}'
TIMEOUT_SECONDS = int(os.getenv('SMOKE_TIMEOUT', '10'))
RETRY_ATTEMPTS = int(os.getenv('SMOKE_RETRIES', '3'))
RETRY_BACKOFF_SECONDS = float(os.getenv('SMOKE_BACKOFF', '1.0'))
# If provided, explicit allowed status codes override default behavior
# Example: SMOKE_ALLOWED_STATUS="200,204,401"
_ALLOWED_STATUS = set(int(x) for x in os.getenv('SMOKE_ALLOWED_STATUS', '').split(',') if x.strip().isdigit())

_DISCOVERED_HEALTH_PATH = {health_literal}
_DISCOVERED_VERSION_PATH = {version_literal}

_TEST_CASES: _t.List[_t.Tuple[str, str]] = [
{cases_literal}
]


def _wait_for_service_up() -> None:
    target = _DISCOVERED_HEALTH_PATH or '/'
    url = BASE_URL.rstrip('/') + target
    session = requests.Session()
    deadline = time.time() + float(os.getenv('SMOKE_WAIT_TIMEOUT', '60'))
    last_err = None
    while time.time() < deadline:
        try:
            resp = session.get(url, timeout=TIMEOUT_SECONDS)
            if resp.status_code < 500:
                return
        except Exception as e:  # noqa: BLE001
            last_err = e
        time.sleep(1.0)
    if last_err:
        raise AssertionError(f'Service not up at {{url}}: {{last_err}}')
    raise AssertionError(f'Service not up at {{url}}: timeout')


@pytest.fixture(scope='session', autouse=True)
def _service_ready() -> None:
    _wait_for_service_up()


def _request_with_retries(method: str, url: str) -> requests.Response:
    session = requests.Session()
    attempt = 0
    while True:
        attempt += 1
        try:
            return session.request(method=method, url=url, timeout=TIMEOUT_SECONDS)
        except Exception:
            if attempt >= RETRY_ATTEMPTS:
                raise
            time.sleep(RETRY_BACKOFF_SECONDS)


@pytest.mark.parametrize('method,path', _TEST_CASES)
def test_smoke_endpoint(method: str, path: str) -> None:
    url = BASE_URL.rstrip('/') + path
    resp = _request_with_retries(method, url)
    if _ALLOWED_STATUS:
        assert resp.status_code in _ALLOWED_STATUS, f"Unexpected status {{resp.status_code}} for {{url}}"
    else:
        assert 200 <= resp.status_code < 400, f"Unexpected status {{resp.status_code}} for {{url}}"


@pytest.mark.smoke
def test_version_endpoint_present_and_valid() -> None:
    if not _DISCOVERED_VERSION_PATH:
        pytest.skip('No /version endpoint discovered in app routes')
    url = BASE_URL.rstrip('/') + _DISCOVERED_VERSION_PATH
    resp = _request_with_retries('GET', url)
    assert resp.status_code == 200
    data = resp.json()
    assert 'version' in data and isinstance(data['version'], str) and data['version'] != ''
"""
    return content


def main(output_path: Optional[str] = None) -> int:
    routes, health_path, version_path = collect_routes()
    output = generate_test_file(routes, health_path, version_path)

    path = Path(output_path) if output_path else OUTPUT_PATH
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(output, encoding='utf-8')
    print(f"Generated smoke tests for {len(routes)} endpoint(s) at {path}")
    return 0


if __name__ == '__main__':
    out = sys.argv[1] if len(sys.argv) > 1 else None
    raise SystemExit(main(out))

