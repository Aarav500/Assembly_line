from typing import List, Dict

def _headers_list_to_ts_set(headers: List[str]) -> str:
    norm = [h.lower() for h in headers]
    unique = []
    for h in norm:
        if h not in unique:
            unique.append(h)
    items = ', '.join([f'"{h}"' for h in unique])
    return f"new Set([{items}])"

CF_WORKER_TS = """
// Cloudflare Worker Edge Proxy (TypeScript)
// Generated by codegen

const API_PREFIX = "{api_prefix}";
const BACKEND_ORIGIN = "{backend_url}";
const ALLOW_ORIGIN = "{cors_origin}";
const PASS_HEADERS = {pass_headers_ts_set};

function makeCorsHeaders(request: Request): Headers {
  const h = new Headers();
  const reqOrigin = request.headers.get('origin') || '*';
  h.set('Access-Control-Allow-Origin', ALLOW_ORIGIN === '*' ? reqOrigin : ALLOW_ORIGIN);
  h.append('Vary', 'Origin');
  h.set('Access-Control-Allow-Methods', 'GET,POST,PUT,PATCH,DELETE,OPTIONS');
  h.set('Access-Control-Allow-Headers', 'Authorization,Content-Type,Accept,X-Requested-With');
  h.set('Access-Control-Max-Age', '86400');
  h.set('Access-Control-Allow-Credentials', 'true');
  return h;
}

function applyCors(headers: Headers, request: Request) {
  const cors = makeCorsHeaders(request);
  for (const [k, v] of cors) headers.set(k, v);
}

export default {
  async fetch(request: Request): Promise<Response> {
    const url = new URL(request.url);

    if (!url.pathname.startsWith(API_PREFIX)) {
      return new Response('Not Found', { status: 404 });
    }

    if (request.method === 'OPTIONS') {
      return new Response(null, { headers: makeCorsHeaders(request) });
    }

    const dest = BACKEND_ORIGIN + url.pathname + (url.search || '');

    const headers = new Headers();
    for (const [k, v] of request.headers) {
      if (PASS_HEADERS.has(k.toLowerCase())) headers.set(k, v);
    }

    const init: RequestInit = {
      method: request.method,
      headers,
      body: ['GET', 'HEAD'].includes(request.method) ? undefined : (request as any).body,
      redirect: 'follow'
    };

    const resp = await fetch(dest, init);

    const outHeaders = new Headers(resp.headers);
    applyCors(outHeaders, request);

    return new Response(resp.body, {
      status: resp.status,
      statusText: resp.statusText,
      headers: outHeaders
    });
  }
};
""".strip() + "\n"

CF_WORKER_JS = """
// Cloudflare Worker Edge Proxy (JavaScript)
// Generated by codegen

const API_PREFIX = "{api_prefix}";
const BACKEND_ORIGIN = "{backend_url}";
const ALLOW_ORIGIN = "{cors_origin}";
const PASS_HEADERS = {pass_headers_ts_set};

function makeCorsHeaders(request) {
  const h = new Headers();
  const reqOrigin = request.headers.get('origin') || '*';
  h.set('Access-Control-Allow-Origin', ALLOW_ORIGIN === '*' ? reqOrigin : ALLOW_ORIGIN);
  h.append('Vary', 'Origin');
  h.set('Access-Control-Allow-Methods', 'GET,POST,PUT,PATCH,DELETE,OPTIONS');
  h.set('Access-Control-Allow-Headers', 'Authorization,Content-Type,Accept,X-Requested-With');
  h.set('Access-Control-Max-Age', '86400');
  h.set('Access-Control-Allow-Credentials', 'true');
  return h;
}

function applyCors(headers, request) {
  const cors = makeCorsHeaders(request);
  for (const [k, v] of cors) headers.set(k, v);
}

export default {{
  async fetch(request) {{
    const url = new URL(request.url);

    if (!url.pathname.startsWith(API_PREFIX)) {{
      return new Response('Not Found', {{ status: 404 }});
    }}

    if (request.method === 'OPTIONS') {{
      return new Response(null, {{ headers: makeCorsHeaders(request) }});
    }}

    const dest = BACKEND_ORIGIN + url.pathname + (url.search || '');

    const headers = new Headers();
    for (const [k, v] of request.headers) {{
      if (PASS_HEADERS.has(k.toLowerCase())) headers.set(k, v);
    }}

    const init = {{
      method: request.method,
      headers,
      body: ['GET', 'HEAD'].includes(request.method) ? undefined : request.body,
      redirect: 'follow'
    }};

    const resp = await fetch(dest, init);

    const outHeaders = new Headers(resp.headers);
    applyCors(outHeaders, request);

    return new Response(resp.body, {{
      status: resp.status,
      statusText: resp.statusText,
      headers: outHeaders
    }});
  }}
}};
""".strip() + "\n"

CF_WRANGLER_TOML = """
name = "edge-proxy"
main = "src/worker.{ext}"
compatibility_date = "2024-01-01"
""".strip() + "\n"

CF_PACKAGE_JSON = """
{{
  "name": "edge-proxy",
  "private": true,
  "version": "0.1.0",
  "scripts": {{
    "dev": "wrangler dev",
    "deploy": "wrangler deploy",
    "preview": "wrangler dev --local"
  }},
  "devDependencies": {{
    "wrangler": "^3.77.0",
    "@cloudflare/workers-types": "^4.20241018.0"
  }}
}}
""".strip() + "\n"

CF_README = """
Cloudflare Workers Edge Proxy

- api prefix: {api_prefix}
- backend: {backend_url}
- cors: {cors_origin}

Quickstart:
- npm i
- npm run dev
- Edit wrangler.toml if needed
""".strip() + "\n"

VC_EDGE_TS = """
// Vercel Edge Function Proxy (TypeScript)
// Generated by codegen

export const config = {{ runtime: 'edge' }};

const API_PREFIX = "{api_prefix}" as const;
const BACKEND_ORIGIN = "{backend_url}" as const;
const ALLOW_ORIGIN = "{cors_origin}" as const;
const PASS_HEADERS = {pass_headers_ts_set} as Set<string>;

function makeCorsHeaders(req: Request): Headers {
  const h = new Headers();
  const reqOrigin = req.headers.get('origin') || '*';
  h.set('Access-Control-Allow-Origin', ALLOW_ORIGIN === '*' ? reqOrigin : ALLOW_ORIGIN);
  h.append('Vary', 'Origin');
  h.set('Access-Control-Allow-Methods', 'GET,POST,PUT,PATCH,DELETE,OPTIONS');
  h.set('Access-Control-Allow-Headers', 'Authorization,Content-Type,Accept,X-Requested-With');
  h.set('Access-Control-Max-Age', '86400');
  h.set('Access-Control-Allow-Credentials', 'true');
  return h;
}

function applyCors(headers: Headers, req: Request) {
  const cors = makeCorsHeaders(req);
  for (const [k, v] of cors) headers.set(k, v);
}

export default async function handler(req: Request): Promise<Response> {
  const url = new URL(req.url);

  if (!url.pathname.startsWith(API_PREFIX)) {
    return new Response('Not Found', { status: 404 });
  }

  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: makeCorsHeaders(req) });
  }

  const dest = BACKEND_ORIGIN + url.pathname + (url.search || '');

  const headers = new Headers();
  for (const [k, v] of req.headers) {
    if (PASS_HEADERS.has(k.toLowerCase())) headers.set(k, v);
  }

  const init: RequestInit = {
    method: req.method,
    headers,
    body: ['GET', 'HEAD'].includes(req.method) ? undefined : (req as any).body,
    redirect: 'follow'
  };

  const resp = await fetch(dest, init);

  const outHeaders = new Headers(resp.headers);
  applyCors(outHeaders, req);

  return new Response(resp.body, {
    status: resp.status,
    statusText: resp.statusText,
    headers: outHeaders
  });
}
""".strip() + "\n"

VC_EDGE_JS = """
// Vercel Edge Function Proxy (JavaScript)
// Generated by codegen

export const config = { runtime: 'edge' };

const API_PREFIX = "{api_prefix}";
const BACKEND_ORIGIN = "{backend_url}";
const ALLOW_ORIGIN = "{cors_origin}";
const PASS_HEADERS = {pass_headers_ts_set};

function makeCorsHeaders(req) {
  const h = new Headers();
  const reqOrigin = req.headers.get('origin') || '*';
  h.set('Access-Control-Allow-Origin', ALLOW_ORIGIN === '*' ? reqOrigin : ALLOW_ORIGIN);
  h.append('Vary', 'Origin');
  h.set('Access-Control-Allow-Methods', 'GET,POST,PUT,PATCH,DELETE,OPTIONS');
  h.set('Access-Control-Allow-Headers', 'Authorization,Content-Type,Accept,X-Requested-With');
  h.set('Access-Control-Max-Age', '86400');
  h.set('Access-Control-Allow-Credentials', 'true');
  return h;
}

function applyCors(headers, req) {
  const cors = makeCorsHeaders(req);
  for (const [k, v] of cors) headers.set(k, v);
}

export default async function handler(req) {
  const url = new URL(req.url);

  if (!url.pathname.startsWith(API_PREFIX)) {
    return new Response('Not Found', { status: 404 });
  }

  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: makeCorsHeaders(req) });
  }

  const dest = BACKEND_ORIGIN + url.pathname + (url.search || '');

  const headers = new Headers();
  for (const [k, v] of req.headers) {
    if (PASS_HEADERS.has(k.toLowerCase())) headers.set(k, v);
  }

  const init = {
    method: req.method,
    headers,
    body: ['GET', 'HEAD'].includes(req.method) ? undefined : req.body,
    redirect: 'follow'
  };

  const resp = await fetch(dest, init);

  const outHeaders = new Headers(resp.headers);
  applyCors(outHeaders, req);

  return new Response(resp.body, {
    status: resp.status,
    statusText: resp.statusText,
    headers: outHeaders
  });
}
""".strip() + "\n"

VC_VERCEL_JSON = """
{{
  "functions": {{
    "api/*.ts": {{ "runtime": "edge" }},
    "api/*.js": {{ "runtime": "edge" }}
  }}
}}
""".strip() + "\n"

VC_README = """
Vercel Edge Function Proxy

- api prefix: {api_prefix}
- backend: {backend_url}
- cors: {cors_origin}

Place files in a Vercel project and deploy. Requests under the prefix will proxy to your backend.
""".strip() + "\n"


def generate_cloudflare_worker(backend_url: str, api_prefix: str, language: str, cors_origin: str, pass_through_headers: list) -> List[Dict[str, str]]:
    ext = 'ts' if language == 'ts' else 'js'
    files: List[Dict[str, str]] = []
    files.append({
        'path': f'cloudflare-workers/wrangler.toml',
        'content': CF_WRANGLER_TOML.format(ext=ext)
    })
    files.append({
        'path': 'cloudflare-workers/package.json',
        'content': CF_PACKAGE_JSON
    })

    pass_set = _headers_list_to_ts_set(pass_through_headers)

    worker_src = (CF_WORKER_TS if language == 'ts' else CF_WORKER_JS).format(
        api_prefix=api_prefix,
        backend_url=backend_url,
        cors_origin=cors_origin,
        pass_headers_ts_set=pass_set
    )
    files.append({
        'path': f'cloudflare-workers/src/worker.{ext}',
        'content': worker_src
    })

    files.append({
        'path': 'cloudflare-workers/README.md',
        'content': CF_README.format(api_prefix=api_prefix, backend_url=backend_url, cors_origin=cors_origin)
    })

    return files


def generate_vercel_edge(backend_url: str, api_prefix: str, language: str, cors_origin: str, pass_through_headers: list) -> List[Dict[str, str]]:
    ext = 'ts' if language == 'ts' else 'js'
    files: List[Dict[str, str]] = []

    files.append({
        'path': 'vercel-edge/vercel.json',
        'content': VC_VERCEL_JSON
    })

    pass_set = _headers_list_to_ts_set(pass_through_headers)

    route_src = (VC_EDGE_TS if language == 'ts' else VC_EDGE_JS).format(
        api_prefix=api_prefix,
        backend_url=backend_url,
        cors_origin=cors_origin,
        pass_headers_ts_set=pass_set
    )
    files.append({
        'path': f'vercel-edge/api/proxy.{ext}',
        'content': route_src
    })

    files.append({
        'path': 'vercel-edge/README.md',
        'content': VC_README.format(api_prefix=api_prefix, backend_url=backend_url, cors_origin=cors_origin)
    })

    return files

