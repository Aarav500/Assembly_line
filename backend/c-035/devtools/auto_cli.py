import importlib
import inspect
import os
import pkgutil
import stat
import sys
from pathlib import Path
from typing import Any

import click

from .core import dev_command  # re-exported by __init__


def _discover_command_functions():
    import devtools.commands as pkg

    commands: list[tuple[str, str, Any]] = []
    for _, modname, ispkg in pkgutil.iter_modules(pkg.__path__):
        if ispkg:
            continue
        module = importlib.import_module(f"{pkg.__name__}.{modname}")
        for attr in dir(module):
            obj = getattr(module, attr)
            if callable(obj) and hasattr(obj, "_dev_meta"):
                meta = getattr(obj, "_dev_meta")
                commands.append((meta["name"], meta.get("help", ""), obj))
    # Ensure stable order by name
    commands.sort(key=lambda t: t[0])
    return commands


def _click_type(annotation):
    if annotation is bool:
        return None  # handled via flag
    if annotation is int:
        return click.INT
    if annotation is float:
        return click.FLOAT
    return click.STRING


def _build_click_command(name: str, help_text: str, func):
    sig = inspect.signature(func)
    params: list[click.Parameter] = []

    for p in sig.parameters.values():
        if p.kind in (inspect.Parameter.VAR_POSITIONAL, inspect.Parameter.VAR_KEYWORD):
            continue

        ann = p.annotation if p.annotation is not inspect._empty else str
        has_default = p.default is not inspect._empty

        if not has_default:
            # Required positional argument
            ctype = _click_type(ann) or click.STRING
            params.append(click.Argument([p.name], type=ctype))
            continue

        default = p.default
        # Boolean flag with --name/--no-name pair
        if ann is bool or isinstance(default, bool):
            params.append(
                click.Option([
                    f"--{p.name.replace('_','-')}/--no-{p.name.replace('_','-')}"
                ],
                default=bool(default),
                help=None,
                show_default=True,
            ))
            continue

        # Optional option with --name
        ctype = _click_type(ann) or click.STRING
        params.append(
            click.Option([f"--{p.name.replace('_','-')}"] , type=ctype, default=default, show_default=True)
        )

    def _callback(*args, **kwargs):
        bound = sig.bind_partial(*args, **kwargs)
        bound.apply_defaults()
        return func(*bound.args, **bound.kwargs)

    return click.Command(name=name, callback=_callback, params=params, help=help_text)


class AutoCLI(click.MultiCommand):
    def list_commands(self, ctx):
        return [name for name, _, _ in _discover_command_functions()]

    def get_command(self, ctx, name):
        for cmd_name, help_text, func in _discover_command_functions():
            if cmd_name == name:
                return _build_click_command(cmd_name, help_text, func)
        return None


@click.group(cls=AutoCLI, invoke_without_command=False)
@click.version_option(package_name="auto_generate_dev_cli")
def cli():
    """Auto-generated dev tools CLI. Discover commands in devtools/commands."""


@cli.command("generate-scripts")
@click.option("--out-dir", default="bin", show_default=True, help="Directory to write command scripts")
def generate_scripts(out_dir: str):
    """Generate standalone shell/batch wrappers for each command."""
    cmds = [name for name, _, _ in _discover_command_functions()]
    os.makedirs(out_dir, exist_ok=True)

    created = []
    for name in cmds:
        # POSIX shell
        sh_path = Path(out_dir) / name
        sh_content = f"""#!/usr/bin/env bash
# Auto-generated by dev generate-scripts
set -euo pipefail
exec python -m devtools.auto_cli {name} "$@"
"""
        sh_path.write_text(sh_content, encoding="utf-8")
        st = os.stat(sh_path)
        os.chmod(sh_path, st.st_mode | stat.S_IEXEC)
        created.append(str(sh_path))

        # Windows batch
        bat_path = Path(out_dir) / f"{name}.bat"
        bat_content = f"""@echo off
REM Auto-generated by dev generate-scripts
python -m devtools.auto_cli {name} %*
"""
        bat_path.write_text(bat_content, encoding="utf-8")
        created.append(str(bat_path))

    click.echo(f"Generated {len(created)} script files in {out_dir}:")
    for c in created:
        click.echo(f" - {c}")


def main():
    cli(prog_name="dev")


if __name__ == "__main__":
    main()

