name: Deploy to AWS VM

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  VM_IP: 3.229.134.38          # EC2 public IP
  VM_USER: ubuntu              # change if your AMI uses a different default user
  PROJECT_DIR: unified_app     # directory on the VM

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # Build .env locally from multi-line secret ENV (you will maintain this)
      - name: Create .env from secret
        run: |
          cat << 'EOF' > .env
          ${{ secrets.ENV }}
          EOF
          echo "Created .env from secrets.ENV"

      # Use ENV secret to run init.sql against RDS
      - name: Run init.sql against RDS
        env:
          ENV_CONTENT: ${{ secrets.ENV }}
        run: |
          set -e
          echo "$ENV_CONTENT" > env_for_db.sh

          # export all KEY=VALUE pairs from your ENV secret
          set -a
          source env_for_db.sh
          set +a

          echo "Running init.sql against RDS host: $DB_HOST, db: $DB_NAME"

          docker run --rm -i postgres:15-alpine \
            sh -c 'PGPASSWORD="$DB_PASSWORD" psql -h "$DB_HOST" -p "${DB_PORT:-5432}" -U "$DB_USER" -d "$DB_NAME"' \
            < database/init.sql

          echo "init.sql completed"

      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan -H ${{ env.VM_IP }} >> ~/.ssh/known_hosts

      - name: Test SSH connection
        run: |
          ssh -i ~/.ssh/id_ed25519 ${{ env.VM_USER }}@${{ env.VM_IP }} "echo 'SSH OK'"

      - name: Copy project files to VM
        run: |
          rsync -avz --delete \
            --exclude='.git' \
            --exclude='.github' \
            --exclude='**/.venvs' \
            --exclude='**/__pycache__' \
            --exclude='**/*.pyc' \
            --exclude='**/logs/*' \
            --exclude='**/data/*' \
            -e "ssh -i ~/.ssh/id_ed25519 -o StrictHostKeyChecking=no" \
            ./ ${{ env.VM_USER }}@${{ env.VM_IP }}:~/${{ env.PROJECT_DIR }}/

      - name: Copy .env to VM
        run: |
          scp -i ~/.ssh/id_ed25519 .env \
            ${{ env.VM_USER }}@${{ env.VM_IP }}:~/${{ env.PROJECT_DIR }}/.env

      - name: Install Docker & docker-compose on VM (if needed) and deploy
        run: |
          ssh -i ~/.ssh/id_ed25519 ${{ env.VM_USER }}@${{ env.VM_IP }} << EOF
            set -e
            cd ~/${{ env.PROJECT_DIR }}

            if ! command -v docker >/dev/null 2>&1; then
              echo "Installing Docker..."
              curl -fsSL https://get.docker.com -o get-docker.sh
              sudo sh get-docker.sh
            fi

            if ! command -v docker-compose >/dev/null 2>&1; then
              echo "Installing docker-compose..."
              sudo curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-\$(uname -s)-\$(uname -m)" \
                -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
            fi

            # Ensure firewall ports (optional â€“ you can also set this in console)
            if command -v ufw >/dev/null 2>&1; then
              sudo ufw allow 22/tcp || true
              sudo ufw allow 80/tcp || true
              sudo ufw allow 443/tcp || true
              sudo ufw allow 3000/tcp || true
              sudo ufw allow 5000/tcp || true
              sudo ufw allow 8080/tcp || true
            fi

            echo "Stopping existing containers..."
            docker-compose down || true

            echo "Building and starting containers..."
            docker-compose pull || true
            docker-compose build
            docker-compose up -d

            echo "Current container status:"
            docker-compose ps
          EOF
